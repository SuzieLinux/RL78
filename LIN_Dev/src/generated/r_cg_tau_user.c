/**
 * @file   r_cg_tau_user.c
 * @author Michel Catudal
 * @date   10 April 2022
 * @version 0.1
 * @brief  timers used for lin
 *
*/
/***********************************************************************************************************************
* Code based on code generated by Applilet4 for RL78/G11 and IAR Systems iccrl78
* Copyright (C) 2016, 2021 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
Includes
***********************************************************************************************************************/
#include "r_cg_macrodriver.h"
#include "r_cg_tau.h"
#include "r_cg_r_cg_userdefine.h"
#include "lin.h"

/***********************************************************************************************************************
Global variables and functions
***********************************************************************************************************************/
/* For TAU0_ch3 pulse measurement */
uint32_t g_tau0_ch3_width = 0UL;
uint16_t time_in_msecs = 0;

/***********************************************************************************************************************
* Function Name: r_tau0_channel1_interrupt
* Description  : This function INTTM01 interrupt service routine.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
#pragma vector = INTTM01_vect
__interrupt static void r_tau0_channel1_interrupt(void)
{
	time_in_msecs++
}
/***********************************************************************************************************************
* Function Name: r_tau0_channel3_interrupt
* Description  : This function INTTM03 interrupt service routine.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
#pragma vector = INTTM03_vect
__interrupt static void r_tau0_channel3_interrupt(void)
{
    if (1U == (TSR03 & _0001_TAU_OVERFLOW_OCCURS))    /* overflow occurs */
    {
        g_tau0_ch3_width = (uint32_t)(TDR03 + 1UL) + 0x10000UL;
    }
    else
    {
        g_tau0_ch3_width = (uint32_t)(TDR03 + 1UL);
    }

    /* This flag should only be set once prior
       after a detection of a wake-up signal */
    if (!break_received)
    {
        /* Set flag */
        break_received = 1;

        /* Re-enable UART0 reception */
        SCR01 |= _4000_SAU_RECEPTION;

        /* Enable UART0 rx interrupts */
        SRMK0 = 0U;
    }

    /* Clear TM03 interrupt flag */
    TMIF03 = 0;
}

/*****************************************************************************
*      @brief Delay in msecs
*
*      @param[in] Number of msecs
*
*      @return None
******************************************************************************/
void delay(uint16_t ms)
{
    time_in_msecs = 0;
    R_TAU0_Channel1_Start();
    while (time_in_msecs < ms);
    R_TAU0_Channel1_Stop();
}

/*****************************************************************************
*      @brief Wait for display to be done
*
*      @param[in] None
*
*      @return -1 if timed out, 0 if display not busy
*******************************************************************************/
int WaitIfBusy(void)
{
    time_in_msecs = 0;
    R_TAU0_Channel1_Start();
    while(VFD_Busy)
    {
        if (time_in_msecs >= 3)
        {
            R_TAU0_Channel1_Stop();
            return -1;
        }
    }

    R_TAU0_Channel1_Stop();
    return 0;
}

void delay_ms(int aTimeMS)
{
    time_in_msecs = 0;
    R_TAU0_Channel1_Start();
    while(time_in_msecs < aTimeMS);
    R_TAU0_Channel1_Stop();
}

