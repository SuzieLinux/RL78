/**
 * @file   r_cg_sau_user.c
 * @author Michel Catudal
 * @date   4 March 2022
 * @version 0.1
 * @brief  r_cg_sau_user Support
 *
*/
/***********************************************************************************************************************
* Code based on code generated by Applilet4 for RL78/G11 and IAR Systems iccrl78
* Copyright (C) 2016, 2021 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
Includes
***********************************************************************************************************************/
#include "r_cg_macrodriver.h"
#include "r_cg_sau.h"
#include "r_cg_userdefine.h"
#include "vfd.h"
#include "lin.h"

/***********************************************************************************************************************
Global variables and functions
***********************************************************************************************************************/
volatile uint8_t break_received;
volatile uint8_t sync_field_received;

/*****************************************************************************
*      @brief Lin Interrupt
*
*      @param[in] None
*
*      @return None
******************************************************************************/
#pragma vector = INTSR0_vect
__interrupt static void r_uart0_interrupt_receive(void)
{
    volatile uint8_t rx_data;

    rx_data = RXD0;

    if (break_received)
    {
        /* If the sync field has been received store the received byte in the receive buffer array
           and increment the received data count otherwise check for sync field */
        if (sync_field_received)
        {
			if ((rx_data == RightAir_LIN_ID) ||
				(rx_data == LeftAir_LIN_ID) ||
				(rx_data == SpareAir_LIN_ID))
            {
                SCR01 &= ~_4000_SAU_RECEPTION;
                if ((rx_data == RightAir_LIN_ID) ||
					(rx_data == LeftAir_LIN_ID) ||
					(rx_data == SpareAir_LIN_ID))
                {
                    ucLIN_CommTimeout = LIN_CommTimeoutValue;
                    TxBuffer[0] = 0xAA;
                    TxBuffer[1] = 0xBB;
                    LIN_Transmit(TxBuffer, 2);
                }
                else
                {
                    Init_LIN_HeaderRx();    // Restart Lin reception
                }
            }
            else
            {
                Init_LIN_HeaderRx();    // Restart Lin reception
            }
        }
        else if (rx_data == 0x55) sync_field_received = 1;
    }
    else
    {
        sync_field_received = 0;
    }
}

/***********************************************************************************************************************
* Function Name: r_csi11_interrupt
* Description  : None
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
#pragma vector = INTCSI11_vect
__interrupt static void r_csi11_interrupt(void)
{
    volatile uint8_t err_type;

    err_type = (uint8_t)(SSR03 & _0001_SAU_OVERRUN_ERROR);
    SIR03 = (uint16_t)err_type;

    if (err_type != 1U)
    {
        if (g_csi11_tx_count > 0U)
        {
            SIO11 = *gp_csi11_tx_address;
            gp_csi11_tx_address++;
            g_csi11_tx_count--;
        }
    }
}

void SPI_Send(uint8_t *aData, uint32_t aLength)
{
    VFD_CS = 0;
    VFD_WR = 0;

	R_CSI11_Send(aData, aLength);
    while(G_CSI11_SendingData);

    VFD_WR = 1;
    VFD_CS = 1;
}


